---
title: Capstone Hint 1
author: 
- name: Tran Thai Hung
  affiliations:
    - OUCRU biostat
date: 'last-modified'
date-format: '[Last version:] MMMM DD, YYYY'
format: 
  html: 
    code-tools:
      source: true
      toggle: false
      caption: none
toc: TRUE
lof: FALSE
lot: FALSE
number-sections: FALSE
thanks: "Please do not circulate."
abstract: ""
keywords: ""
editor: visual
---

```{r load-library, message=FALSE, warning=FALSE}
#load library
library(readxl)
library(dplyr)
library(data.table)
library(stringr)
library(ggplot2)
library(gtsummary)
library(Hmisc)
library(gt)
library(tidyr)
library(stats)
```

# 1. Load data

Import all the sheets in raw data `2-10-2020-_03TS_V1_Data.xls`. Convert "UNKNOWN" value to NA, and "Y"/"N" to standard factorized "yes"/"no" which will be convenient as later gtsummary will automatically detect dichotomous variables.

<details>

<summary>[Import raw data]{style="color:blue"}</summary>

```{r load-data, message=FALSE, warning=FALSE}
# Define file path
daily_file_path <- here::here("data", "2-10-2020-_03TS_V1_Data.xls")

# Define sheets to import
sheets <- c(
  "ENR",
  "ADM",
  "VENT",
  "VENT_VENTILATION",
  "VENT_TracheSupp",
  "DAILY",
  "DAILY_DAILY",
  "COMP",
  "FU",
  "DAILY_FU",
  "DAILY_FU_GridFU",
  "S_AE"
)

# Read and store data in a named list
data_list <- lapply(sheets, function(sheet) {
  df <- read_excel(daily_file_path, sheet = sheet)
  
  # Replace "UNKNOWN" with NA, convert "Y"/"N" to "yes"/"no"
  df <- df %>%
    mutate(across(
      where(is.character),
      ~ case_when(
        .x == "Y" ~ "yes",
        .x == "N" ~ "no",
        .x == "UNKNOWN" ~ NA_character_,
        TRUE ~ .x
      )
    )) %>%
    mutate(across(
      where( ~ all(.x %in% c("yes", "no", NA), na.rm = TRUE)),
      ~ factor(
        .x,
        levels = c("no", "yes"),
        labels = c(0, 1),
        exclude = NULL
      )
    ))  # Ensure both levels exist
  
  setNames(df, tolower(names(df)))
})

# Assign data frames to variables in the global environment
list2env(setNames(data_list, tolower(sheets)), envir = .GlobalEnv)


# another method
# for (sheet in sheets) {
#   assign(tolower(sheet), read_excel(daily_file_path, sheet = sheet) %>%
#            setNames(tolower(names(.))))
# }
```

</details>

Import the allocation data of treatment arm `03TS_Randlist.xlsx` and recode the values as being stated in the dictionary.

<details>

<summary>[Import random allocation data]{style="color:blue"}</summary>

```{r}
allocation_file_path <- here::here("data", "03TS_Randlist.xlsx")


# Read and process allocation data
allocation_data <- read_excel(allocation_file_path, sheet = "Allocation") %>%
  setNames(tolower(names(.)))

randolist <- allocation_data %>%  filter(row_number() %in% c(1:272)) %>%
  rename(arm = r.arm) %>%
  mutate(
    pat.id = str_replace(pat.id, ".*-", ""),
    usubjid = paste("003", pat.id, sep = "-"),
    arm = case_when(
      arm == "14 ampoules: TETANUS ANTITOXIN (IM) + 2 prefilled-syringes : TETAGAM®P (intrathecal))" ~ "equine and intrathecal",
      arm == "14 ampoules: TETANUS ANTITOXIN (IM)" ~ "equine and sham",
      arm == "12 prefilled-syringes : TETAGAM®P (IM) + 2 prefilled-syringes : TETAGAM®P (intrathecal))" ~ "human and intrathecal",
      arm == "12 prefilled-syringes : TETAGAM®P (IM)" ~ "human and sham"
    )
  )

```

</details>

Import the inclusion and exclusion data `Protocol violations, exclusions, withdrawals.xlsx`. Fix the inconsistency in sheet `IM ITT` which used `id` instead of `usubjid`.

<details>

<summary>[Import inclusion and exclusion data]{style="color:blue"}</summary>

```{r}
violations_file_path <- here::here("data", "Protocol violations, exclusions, withdrawals.xlsx")

# Import all sheets from the Protocol violations file
all_sheets <- excel_sheets(violations_file_path)  # Get sheet names
violations_data <- lapply(all_sheets, function(sheet) {
  data <- read_excel(violations_file_path, sheet = sheet)
  colnames(data) <- tolower(colnames(data))  # Convert column names to lowercase
  data
})
names(violations_data) <- all_sheets  # Assign sheet names to the list


for (name in names(violations_data)) {
  # Modify the name: make lowercase and replace spaces with underscores
  modified_name <- gsub(" ", "_", tolower(name))
  
  # Assign the data frame to the modified name
  assign(modified_name, violations_data[[name]])
}

im_itt <- im_itt %>%
  rename(usubjid = "id")
```

</details>

Exclude all `usubjid` that were in pilot study and/or withdrew the consent.

<details>

<summary>[Filter data]{style="color:blue"}</summary>

```{r}
library(dplyr)
library(purrr)


# Identify subjects to be excluded
excluded_subjects <- unique(c(pilot$usubjid, withdrawals$usubjid))

# List of dataset names
dataset_names <- c(
  "vent",
  "enr",
  "adm",
  "vent_ventilation",
  "vent_trachesupp",
  "daily",
  "daily_daily",
  "comp",
  "fu",
  "daily_fu",
  "daily_fu_gridfu",
  "s_ae"
)

# Apply filtering to all datasets and reassign them
filtered_datasets <- map(setNames(dataset_names, dataset_names), ~ {
  get(.x) %>% filter(!usubjid %in% excluded_subjects)
})

# Assign filtered datasets back to their original names
list2env(filtered_datasets, envir = .GlobalEnv)
```

</details>

Relabel variable and add units. So they will appear nicely in the table later. You might notice that I have created a new variable `bmi` here too. You could try to compute `APACHE II score`, `SOFA score` and `Tetanus Severity Score` too.

<details>

<summary>[Baseline data]{style="color:blue"}</summary>

```{r}
baseline_data <- enr %>%
  select(-entry) %>%
  left_join(adm, by = "usubjid") %>%
  left_join(randolist %>% select(usubjid, arm), by = "usubjid")

baseline_data_raw <- upData(
  baseline_data,
  bmi = weight / ((height / 100) ^ 2),
  #new variable derived from weight and height
  labels = c(
    age = "Age (years)",
    icudays = "Days in ICU",
    sex = "Sex",
    weight = "Weight (kg)",
    height = "Height (cm)",
    bmi = "BMI (kg/m2)",
    source = "Source",
    tetanus = "Tetanus",
    hypertension = "Hypertension",
    myocardialinfart = "Myocardial infarction",
    angina = "Angina",
    perivascular = "Perivascular",
    chronicpul = "Chronic pulmonary",
    connectivetissue = "Connective tissue",
    mildliver = "Mild liver",
    hemiplegia = "Hemiplegia",
    diawithchronic = "Diabetes with chronic",
    severeliver = "Severe liver",
    aids = "AIDS",
    cardiacfailureiii = "Cardiac failure III",
    cardiacfailureiv = "Cardiac failure IV",
    cerebrovascular = "Cerebrovascular",
    severeresp = "Severe respiratory",
    pepticulcer = "Peptic ulcer",
    diabetes = "Diabetes",
    severekidney = "Severe kidney",
    malignancy = "Malignancy",
    tumour = "Tumour",
    dementia = "Dementia",
    comorbidityoth1 = "Other comorbidity 1",
    comorbidityoth2 = "Other comorbidity 2",
    electivesurgery = "Elective surgery",
    emergencysurgery = "Emergency surgery",
    timetoadm = "Duration of illness (days)",
    incubationperiod = "Incubation period (days)",
    incuperiodonset = "Period of onset (days)",
    wound = "Wound",
    diffbreath = "Difficulty breathing on admission",
    ablettscore = "Ablett Score on admission",
    asa = "ASA score",
    maxtemp = "Maximum temperature during 1st day",
    resp = "Respiratory rate",
    fio2 = "FiO2",
    spo2 = "SpO2",
    pao2 = "PAO2",
    ph = "PH",
    plt = "Platelet count",
    wbc = "White blood cell count",
    hct = "Haematocrit",
    maxhr = "Max HR",
    minhr = "Min HR",
    maxsbp = "Max SBP",
    worstdbp = "Worst DBP",
    worstsbp = "Worst SBP",
    vaso = "Vasopressors",
    bili = "Bilirubin",
    na = "Sodium",
    k = "Potassium",
    creat = "Creatinine",
    renalfailure = "Acute Renal Failure"
  )
)
```

</details>

# 2. Baseline table

When we write the code to create baseline tables for 5 different populations, we might notice that they are just repeated except for a first few filtering steps. Therefore, it's good to wrap those repeated codes in a function to make our code neat and if we would like to make any changes, we just need to change at one place. This example is not optimal. Let's think some ways to improve it based on what you have learnt in Rcafe course.

<details>

<summary>[Wrap repeated code in a function]{style="color:blue"}</summary>

```{r}
generate_baseline_summary <- function(baseline_data) {
  library(dplyr)
  library(gtsummary)
  
  # Select relevant columns
  baseline_data <- baseline_data %>%
    select(usubjid, age, sex, bmi, source, tetanus, icudays, outcome, hypertension, 
           myocardialinfart, angina, perivascular, chronicpul, connectivetissue, 
           mildliver, hemiplegia, diawithchronic, severeliver, aids, cardiacfailureiii, 
           cerebrovascular, severeresp, pepticulcer, diabetes, severekidney, malignancy, 
           tumour, dementia, renalfailure, electivesurgery, emergencysurgery, timetoadm, 
           incubationperiod, incuperiodonset, wound, diffbreath, ablettscore, asa, 
           maxtemp, resp, fio2, spo2, pao2, ph, plt, wbc, hct, maxhr, minhr, maxsbp, 
           worstdbp, worstsbp, vaso, na, k, creat, Arm) %>% 
    as.data.frame(stringsAsFactors = FALSE)
  
  # Identify factor variables, excluding "Arm"
  factor_vars <- setdiff(names(baseline_data)[sapply(baseline_data, is.factor)], "Arm")
  
  # Create a formula dynamically: c(var1, var2, ...) ~ "1"
  value_formula <- as.formula(paste("c(", paste(factor_vars, collapse = ", "), ") ~ '1'"))
  
  # Generate the summary table
  baseline_table <- baseline_data %>%
    select(-usubjid) %>%
    tbl_summary(
      by = Arm, 
      missing = "no", # Handle missing values
      statistic = list(
        all_continuous() ~ "{median} ({p25}, {p75})", 
        all_categorical() ~ "{n}/{N} ({p}%)"
      ),
      digits = list(all_continuous() ~ 1),
      type = list(fio2 ~ "continuous"),
      value = value_formula  # Apply "1" to all factor variables
    ) %>%
    modify_header(label ~ "Variable") %>%
    bold_labels()
  
  return(baseline_table)
}

```

</details>

::: panel-tabset
### Baseline table IT_ITT

<details>

<summary>Click to expand/collapse</summary>

```{r}
# Prepare baseline data
baseline_data <- baseline_data_raw %>% 
  mutate( 
    Arm = recode(arm, 
                 "equine and intrathecal" = 0, 
                 "human and intrathecal" = 0,
                 "human and sham" = 1,
                 "equine and sham" = 1),
    Arm = factor(Arm, levels = c(0,1), labels = c("Intrathecal treatment", "Sham procedure"))
  )

generate_baseline_summary(baseline_data)
```

</details>

::: column-margin
Apply our `generate_baseline_summary` function to make tables for 5 different populations. Note how each population is filtered and grouped into treatment arms according to the `Statistical analysis plan`
:::

### Baseline table IM_ITT

<details>

<summary>Click to expand/collapse</summary>

```{r}
baseline_data <- baseline_data_raw %>% 
  filter(!usubjid %in% im_itt$usubjid) %>% 
  mutate(
    Arm=recode(arm, "equine and intrathecal" = 0, 
               "equine and sham" = 0,
               "human and sham" = 1,
               "human and intrathecal" = 1),
    Arm=factor(Arm, levels=c(0,1), labels=c("Equine IM","Human IM"))
  )

generate_baseline_summary(baseline_data)
```

</details>

### Baseline table IT_PP

<details>

<summary>Click to expand/collapse</summary>

```{r}
baseline_data <- baseline_data_raw %>% 
  filter(!usubjid %in% it_per_protocol$usubjid) %>% 
  mutate( 
    Arm = recode(arm, 
                 "equine and intrathecal" = 0, 
                 "human and intrathecal" = 0,
                 "human and sham" = 1,
                 "equine and sham" = 1),
    Arm = factor(Arm, levels = c(0,1), labels = c("Intrathecal treatment", "Sham procedure"))
  )

generate_baseline_summary(baseline_data)
```

</details>

### Baseline table IM_PP

<details>

<summary>Click to expand/collapse</summary>

```{r}
baseline_data <- baseline_data_raw %>% 
  filter(!usubjid %in% im_per_protocol$usubjid) %>% 
  mutate( 
    Arm=recode(arm,
               "equine and intrathecal" = 0, 
               "equine and sham" = 0,
               "human and sham" = 1,
               "human and intrathecal" = 1),
    Arm=factor(Arm, levels=c(0,1), labels=c("Equine IM","Human IM"))
  )

generate_baseline_summary(baseline_data)
```

</details>

### Baseline table IM_ALL

<details>

<summary>Click to expand/collapse</summary>

```{r}
baseline_data <- baseline_data_raw %>%
  mutate(
    Arm = recode(
      arm,
      "equine and intrathecal" = 0,
      "equine and sham" = 0,
      "human and sham" = 1,
      "human and intrathecal" = 1
    ),
    Arm = ifelse(prehtig == 1, 2, Arm),
    Arm = factor(
      Arm,
      levels = c(0, 1, 2),
      labels = c("Equine IM", "Human IM", "Equine IM pre hospital")
    )
  )

generate_baseline_summary(baseline_data)
```

</details>
:::

# 3. Compute Apache II score

The appendix of how `Tetanus Severity, SOFA, APACHE II` calculated is available [here](https://github.com/OUCRU-Modelling/R-cafe/blob/main/capstone_exercises/scoring_appendix.docx) 

<details>

<summary>[Prepare data for Apache II scoring]{style="color:blue"}</summary>

```{r apache ii data}
## Calculate scores

### Create the data table for apache.ii

apache.ii_data <-
  adm %>% select(usubjid, maxtemp, gcs, resp, fio2, spo2, pao2, ph, plt, wbc, hct, maxhr, minhr, maxsbp, worstsbp, worstdbp, bili, na, k, creat, electivesurgery, emergencysurgery, immunocompromised, severeresp, cardiacfailureiv, diawithchronic, severeliver) %>%
   left_join(enr, by="usubjid") %>% select (usubjid, age, randtc, maxtemp, gcs, resp, fio2, spo2, pao2, ph, plt, wbc, hct, maxhr, minhr, maxsbp, worstsbp, worstdbp, bili, na, k, creat, electivesurgery, emergencysurgery, immunocompromised, severeresp, cardiacfailureiv, diawithchronic, severeliver) %>%
  mutate(
    temp = structure(maxtemp, label="Maximum temperature during 1st day"),
    worstdbp = structure(worstdbp, label="Worst DBP"),
    worstsbp = structure(worstsbp, label="Worst SBP"),
    rr = structure(resp, label="Respiratory rate"),
    fio2 = structure(fio2, label="FiO2"),
    spo2 = structure(spo2, label="SpO2"),
    pao2 = structure(pao2, label="PAO2"),
    ph = structure(ph, label="PH"),
    plt = structure(plt, label="Platelet count"),
    wbc = structure(wbc, label="White blood cell count"),
    hct = structure(hct, label="Haematorcrit"),
    hr = pmax(maxhr, minhr),
    hr = structure(hr, label="HR"),
    maxsbp = structure(maxsbp, label="Max SBP"),
    sodium = structure(na, label="Sodium"),
    potassium = structure(k, label="Potassium"),
    creatinine = structure(creat, label="Creatinine"),
    map = worstdbp + (worstsbp-worstdbp)/3,
    map = structure(map, label="Mean Arterial Pressure"),
    gcs = structure(gcs, label="GCS"),
    age = structure(age, label="Age", unit="years"),
    elective = electivesurgery,
    emergency = emergencysurgery,
    chronic = case_when(
      immunocompromised == "1" ~ 1,
      severeresp == "1" ~ 1,
      cardiacfailureiv == "1" ~ 1,
      diawithchronic == "1" ~ 1,
      severeliver == "1" ~ 1,
      TRUE ~ 0
    )
,
    chronic = factor(chronic, levels=c(0,1), labels=c("0","1"))
  ) %>% 
  select(usubjid, temp, map, hr, rr, fio2, pao2, ph, sodium, potassium, creatinine, hct, wbc, gcs, age, elective, emergency, chronic)
```

</details>

<details>

<summary>[Write function to compute Apache II score]{style="color:blue"}</summary>

```{r apache ii}
calculate_apache_ii <- function(data) {
  data <- data %>%
    mutate(
      temp_score = case_when(
        temp >= 41 ~ 4,
        temp >= 39 ~ 3,
        temp >= 38.5 ~ 1,
        TRUE ~ 0
      ),
      map_score = case_when(
        map >= 160 | map < 40 ~ 4,
        map >= 130 | map < 50 ~ 3,
        map >= 110 | map < 70 ~ 2,
        TRUE ~ 0
      ),
      hr_score = case_when(
        hr >= 180 | hr < 40 ~ 4,
        hr >= 140 | hr < 55 ~ 3,
        hr >= 110 | hr < 70 ~ 2,
        TRUE ~ 0
      ),
      rr_score = case_when(
        rr >= 50 | rr < 6 ~ 4,
        rr >= 35 ~ 3,
        rr < 10 ~ 2,
        rr >= 25 | rr < 12 ~ 1,
        TRUE ~ 0
      ),
      pao2_score = case_when(
        fio2 > 0.5 ~ 0,
        pao2 < 55 ~ 4,
        pao2 <= 60 ~ 2,
        pao2 <= 70 ~ 1,
        TRUE ~ 0
      ),
      ph_score = case_when(
        ph >= 7.7 | ph < 7.15 ~ 4,
        ph >= 7.6 | ph < 7.25 ~ 3,
        ph < 7.33 ~ 2,
        ph >= 7.5 ~ 1,
        TRUE ~ 0
      ),
      sodium_score = case_when(
        sodium >= 180 | sodium <= 110 ~ 4,
        sodium >= 160 | sodium < 120 ~ 3,
        sodium >= 155 | sodium < 130 ~ 2,
        sodium >= 150 ~ 1,
        TRUE ~ 0
      ),
      potassium_score = case_when(
        potassium >= 7 | potassium < 2.5 ~ 4,
        potassium >= 6 ~ 3,
        potassium < 3 ~ 2,
        potassium >= 5.5 | potassium < 3.5 ~ 1,
        TRUE ~ 0
      ),
      creatinine_score = case_when(
        creatinine >= 210 ~ 4,
        creatinine >= 178 ~ 3,
        creatinine >= 133 | creatinine < 54 ~ 2,
        TRUE ~ 0
      ),
      hct_score = case_when(
        hct >= 60 | hct < 20 ~ 4,
        hct >= 50 | hct < 30 ~ 2,
        hct >= 46 ~ 1,
        TRUE ~ 0
      ),
      wbc_score = case_when(
        wbc >= 40 | wbc < 1 ~ 4,
        wbc >= 20 | wbc < 3 ~ 2,
        wbc >= 15 ~ 1,
        TRUE ~ 0
      ),
      gcs_score = 15 - gcs,
      age_score = case_when(
        age >= 75 ~ 6,
        age >= 65 ~ 5,
        age >= 55 ~ 3,
        age >= 45 ~ 2,
        TRUE ~ 0
      ),
      elective_score = case_when(
        elective == "1" ~ 5,
        TRUE ~ 0
      ),
      emergency_score = case_when(
        emergency == "1" ~ 5,
        TRUE ~ 0
      ),
      chronic_score = case_when(
        chronic == "1" ~ 5,
        TRUE ~ 0
      ),
      apache_ii_score = temp_score + map_score + hr_score + rr_score +
        pao2_score + ph_score + sodium_score + potassium_score + creatinine_score +
        hct_score + wbc_score + gcs_score + age_score + elective_score + emergency_score + chronic_score,
      apache_ii_score = structure(apache_ii_score, label = "Apache II score")
    )
  return(data)
}
```

</details>

<details>

<summary>[Apply the `calculate_apache_ii` to `apache.ii_data` and update the score to `baseline_data_raw`]{style="color:blue"}</summary>

```{r apache ii score}
apache.ii.score <- calculate_apache_ii(apache.ii_data)
baseline_data_raw <- baseline_data_raw %>% left_join(apache.ii.score %>% select(usubjid, apache_ii_score), by = "usubjid")
```

</details>

Because we has wrapped the repeated code to create baseline table into `generate_baseline_summary` function, we just need to add the `apache_ii_score` variable in the `select` part of `generate_baseline_summary` once and then apply it to our subset data.

<details>

<summary>[Update `generate_baseline_summary` function]{style="color:blue"}</summary>

```{r}
generate_baseline_summary <- function(baseline_data) {
  library(dplyr)
  library(gtsummary)
  
  # Select relevant columns
  baseline_data <- baseline_data %>%
    select(usubjid, age, sex, bmi, source, tetanus, icudays, outcome, hypertension, 
           myocardialinfart, angina, perivascular, chronicpul, connectivetissue, 
           mildliver, hemiplegia, diawithchronic, severeliver, aids, cardiacfailureiii, 
           cerebrovascular, severeresp, pepticulcer, diabetes, severekidney, malignancy, 
           tumour, dementia, renalfailure, electivesurgery, emergencysurgery, timetoadm, 
           incubationperiod, incuperiodonset, wound, diffbreath, ablettscore, asa, 
           maxtemp, resp, fio2, spo2, pao2, ph, plt, wbc, hct, maxhr, minhr, maxsbp, 
           worstdbp, worstsbp, vaso, na, k, creat, apache_ii_score, Arm) %>% #add apache_ii_score
    as.data.frame(stringsAsFactors = FALSE)
  
  # Identify factor variables, excluding "Arm"
  factor_vars <- setdiff(names(baseline_data)[sapply(baseline_data, is.factor)], "Arm")
  
  # Create a formula dynamically: c(var1, var2, ...) ~ "1"
  value_formula <- as.formula(paste("c(", paste(factor_vars, collapse = ", "), ") ~ '1'"))
  
  # Generate the summary table
  baseline_table <- baseline_data %>%
    select(-usubjid) %>%
    tbl_summary(
      by = Arm, 
      missing = "no", # Handle missing values
      statistic = list(
        all_continuous() ~ "{median} ({p25}, {p75})", 
        all_categorical() ~ "{n}/{N} ({p}%)"
      ),
      digits = list(all_continuous() ~ 1),
      type = list(fio2 ~ "continuous"),
      value = value_formula  # Apply "1" to all factor variables
    ) %>%
    modify_header(label ~ "Variable") %>%
    bold_labels()
  
  return(baseline_table)
}

```

</details>

::: panel-tabset
### Baseline table IT_ITT

<details>

<summary>[Click to expand/collapse]{style="color:blue"}</summary>

```{r}
# Prepare baseline data
baseline_data <- baseline_data_raw %>% 
  mutate( 
    Arm = recode(arm, 
                 "equine and intrathecal" = 0, 
                 "human and intrathecal" = 0,
                 "human and sham" = 1,
                 "equine and sham" = 1),
    Arm = factor(Arm, levels = c(0,1), labels = c("Intrathecal treatment", "Sham procedure"))
  )

generate_baseline_summary(baseline_data)
```

</details>

::: column-margin
If we repeat our codes, we have to repeat our changes too. However, if we wrap them in a function, we only need to make changes in that function.
:::

### Baseline table IM_ITT

<details>

<summary>[Click to expand/collapse]{style="color:blue"}</summary>

```{r}
baseline_data <- baseline_data_raw %>% 
  filter(!usubjid %in% im_itt$usubjid) %>% 
  mutate(
    Arm=recode(arm, "equine and intrathecal" = 0, 
               "equine and sham" = 0,
               "human and sham" = 1,
               "human and intrathecal" = 1),
    Arm=factor(Arm, levels=c(0,1), labels=c("Equine IM","Human IM"))
  )

generate_baseline_summary(baseline_data)
```

</details>

### Baseline table IT_PP

<details>

<summary>[Click to expand/collapse]{style="color:blue"}</summary>

```{r}
baseline_data <- baseline_data_raw %>% 
  filter(!usubjid %in% it_per_protocol$usubjid) %>% 
  mutate( 
    Arm = recode(arm, 
                 "equine and intrathecal" = 0, 
                 "human and intrathecal" = 0,
                 "human and sham" = 1,
                 "equine and sham" = 1),
    Arm = factor(Arm, levels = c(0,1), labels = c("Intrathecal treatment", "Sham procedure"))
  )

generate_baseline_summary(baseline_data)
```

</details>

### Baseline table IM_PP

<details>

<summary>[Click to expand/collapse]{style="color:blue"}</summary>

```{r}
baseline_data <- baseline_data_raw %>% 
  filter(!usubjid %in% im_per_protocol$usubjid) %>% 
  mutate( 
    Arm=recode(arm,
               "equine and intrathecal" = 0, 
               "equine and sham" = 0,
               "human and sham" = 1,
               "human and intrathecal" = 1),
    Arm=factor(Arm, levels=c(0,1), labels=c("Equine IM","Human IM"))
  )

generate_baseline_summary(baseline_data)
```

</details>

### Baseline table IM_ALL

<details>

<summary>[Click to expand/collapse]{style="color:blue"}</summary>

```{r}
baseline_data <- baseline_data_raw %>%
  mutate(
    Arm = recode(
      arm,
      "equine and intrathecal" = 0,
      "equine and sham" = 0,
      "human and sham" = 1,
      "human and intrathecal" = 1
    ),
    Arm = ifelse(prehtig == 1, 2, Arm),
    Arm = factor(
      Arm,
      levels = c(0, 1, 2),
      labels = c("Equine IM", "Human IM", "Equine IM pre hospital")
    )
  )

generate_baseline_summary(baseline_data)
```

</details>
:::

# 4. Adverse event table

<details>

<summary>[Import adverse event data]{style="color:blue"}</summary>

```{r load ae dataset}
# Define file path
ae_file_path <- here::here("data", "AE.SAE DATA SHEET.xls")

#Import AEs and SAEs data

sae_gridae <- read_excel(ae_file_path,sheet = "S_AE_GridAE")
sae_gridsae <- read_excel(ae_file_path,sheet = "S_AE_GridSAE")

names(sae_gridae) <- tolower(names(sae_gridae))
names(sae_gridsae) <- tolower(names(sae_gridsae))

sae_gridae <- sae_gridae %>%
  filter(!usubjid %in% excluded_subjects)

sae_gridsae <- sae_gridsae %>%
  filter(!usubjid %in% excluded_subjects)
```

</details>

According to the protocol, the following events will be excluded from adverse event reporting AE.SAE DATA SHEET:  `SAE_GRID_AE.CTCAENAME = “Nasogastric tube”; “Urinary Catheter”; “Tracheostomy”; “Mechanical ventilation” and “ANSD”`. 

Use `filter` function

<details>

<summary>[Filter events that do not belong to adverse event]{style="color:blue"}</summary>

```{r}
any_ae <- sae_gridae %>% 
  filter(ctcaename!="Nasogastric tube" & ctcaename!="Urinary Catheter" & ctcaename!="Tracheostomy" & ctcaename!="Mechanical ventilation" & ctcaename!="ANSD") 

any_ae <- upData(
  any_ae,
  labels = c(
    ctcaename = "Adverse event names",
    posrelunrel = "Relatedness to treatment",
    unexp = "Unexpected AEs"
  )
)
```

</details>

In this exercise, I will create the adverse event for the IT_ITT only. You can filter the data to create tables for other populations. Let's first add the `Arm` information from baseline data to the `any_ae` by `left_join`

<details>

<summary>[Prepare population for IT_ITT and add `Arm` to `any_ae`]{style="color:blue"}</summary>
```{r}
# Prepare baseline data
baseline_data <- baseline_data_raw %>% 
  mutate( 
    Arm = recode(arm, 
                 "equine and intrathecal" = 0, 
                 "human and intrathecal" = 0,
                 "human and sham" = 1,
                 "equine and sham" = 1),
    Arm = factor(Arm, levels = c(0,1), labels = c("Intrathecal treatment", "Sham procedure"))
  )

data_ae <- any_ae %>% left_join(select(baseline_data, c(usubjid, Arm)))
```

</details>

As I mentioned in the capstone exercise, you can adjust the tables format based on your experience and needs. In this section, I use the format that looks like a published paper from OUCRU's project in *NEJM* ([link](https://www.nejm.org/doi/full/10.1056/NEJMoa2216218#t3)).

![](imgs/capstone_hint/nejmoa2216218_t3.jpg)

If you’re unsure where to start, don’t worry—let’s break it down step by step. 

1. **Count occurrences**: Create two separate data frames—one for the number of participants and another for the number of events for each type of adverse event, stratified by study arm.  
2. **Calculate percentages**: Determine the total number of participants (full IDs) and compute the percentage for each adverse event.  
3. **Merge data**: Join the two data frames into a single table.  
4. **(Optional) Statistical test**: Compute the p-value using a chi-square or Fisher's exact test. While p-values are generally not recommended for adverse event tables, some journals require them.  
5. **Format the table**: Use the `gt` package to convert the final data frame into a customized, publication-ready table.  

<details>

<summary>[1. Create two counting tables]{style="color:blue"}</summary>

```{r warning=F, message=F}
create_summary_table <- function(data, arm_name, total_subjects) {
  summary_table <- data %>%
    filter(Arm == arm_name) %>%
    count(ctcaename, name = "n episode") %>%
    left_join(
      data %>%
        filter(Arm == arm_name) %>%
        distinct(ctcaename, usubjid) %>%  # Ensure unique patient-event pairs
        count(ctcaename, name = "n patient"),
      by = "ctcaename"
    ) %>%
    arrange(desc(`n episode`)) %>%
    mutate(ctcaename = as.character(ctcaename))

  # **Fix total row:**
  total_unique_patients <- data %>%
    filter(Arm == arm_name) %>%
    distinct(usubjid) %>%
    nrow()  # Count unique patients with any adverse event

  total_row <- tibble(
    ctcaename = "Total",
    `n episode` = sum(summary_table$`n episode`, na.rm = TRUE),
    `n patient` = total_unique_patients  # Correct total count of affected patients
  )

  bind_rows(total_row, summary_table) %>%
    mutate(`n patient (%)` = sprintf("%d (%.1f%%)", `n patient`, `n patient` / total_subjects * 100))
}

# Get total subjects per arm
total_subjects <- baseline_data %>%
  group_by(Arm) %>%
  summarise(total = n_distinct(usubjid), .groups = "drop")

# Create tables for both arms
summary_intrathecal <- create_summary_table(data_ae, "Intrathecal treatment", total_subjects$total[total_subjects$Arm == "Intrathecal treatment"])
summary_sham <- create_summary_table(data_ae, "Sham procedure", total_subjects$total[total_subjects$Arm == "Sham procedure"])
```

</details>

<details>

<summary>[2&3. Calculate percentage and merge table]{style="color:blue"}</summary>

```{r warning=F, message=F}
final_summary <- full_join(summary_intrathecal, summary_sham, by = "ctcaename", suffix = c(" (Intrathecal)", " (Sham)")) %>%
  mutate(across(where(is.numeric) & (contains("n episode") | contains("n patient")), ~ replace_na(., 0))) %>%
  mutate(
    `n patient (%) (Sham)` = sprintf("%d (%.1f%%)", `n patient (Sham)`, `n patient (Sham)` / total_subjects$total[total_subjects$Arm == "Sham procedure"] * 100),
    `n patient (%) (Intrathecal)` = sprintf("%d (%.1f%%)", `n patient (Intrathecal)`, `n patient (Intrathecal)` / total_subjects$total[total_subjects$Arm == "Intrathecal treatment"] * 100)
  )
```

</details>

<details>

<summary>[4. Calculate p-values]{style="color:blue"}</summary>
```{r warning=F, message=F}
# Calculate p-values
compute_p_value <- function(sham, intrathecal, sham_total, intrathecal_total) {
  if (sham + intrathecal > 0) {
    matrix_data <- matrix(c(sham, sham_total - sham, intrathecal, intrathecal_total - intrathecal), nrow = 2, byrow = TRUE)
    format.pval(fisher.test(matrix_data)$p.value, digits = 3, eps = 0.001)
  } else {
    NA
  }
}

final_summary <- final_summary %>%
  rowwise() %>%
  mutate(`p value` = compute_p_value(`n patient (Sham)`, `n patient (Intrathecal)`,
                                     total_subjects$total[total_subjects$Arm == "Sham procedure"],
                                     total_subjects$total[total_subjects$Arm == "Intrathecal treatment"])) %>%
  ungroup()

# Keep relevant columns
final_summary <- final_summary %>%
  select(
    ctcaename,
    `n episode (Sham)`, `n patient (%) (Sham)`,
    `n episode (Intrathecal)`, `n patient (%) (Intrathecal)`,
    `p value`
  )
```

</details>

<details>

<summary>[5. Turn data frame to customized formatted table]{style="color:blue"}</summary>

```{r warning=F, message=F}
# Convert to gt table with grouped headers
final_summary_gt <- final_summary %>%
  gt() %>%
  tab_header(title = md("**Comparison of Adverse Events by Arm**")) %>%
  cols_label(
    ctcaename = md("**Type of adverse event**"),
    `n episode (Sham)` = md("**n episode**"),
    `n patient (%) (Sham)` = md("**n patient**"),
    `n episode (Intrathecal)` = md("**n episode**"),
    `n patient (%) (Intrathecal)` = md("**n patient**"),
    `p value` = md("**p value**")
  ) %>%
  tab_spanner(
    label = md(sprintf("**Sham procedure (N=%d)**", total_subjects$total[total_subjects$Arm == "Sham procedure"])),
    columns = c(`n episode (Sham)`, `n patient (%) (Sham)`)
  ) %>%
  tab_spanner(
    label = md(sprintf("**Intrathecal treatment (N=%d)**", total_subjects$total[total_subjects$Arm == "Intrathecal treatment"])),
    columns = c(`n episode (Intrathecal)`, `n patient (%) (Intrathecal)`)
  ) %>%
  fmt_number(columns = starts_with("n episode"), decimals = 0) %>%
  tab_options(table.font.size = "medium") %>%
  tab_style(
    style = list(cell_text(weight = "bold")),
    locations = cells_body(rows = 1)  # Bold the total row
  )

# Print the table
final_summary_gt
```

</details>

Now, let's wrap our code into a single function so it can be applied to other populations. However, turning these code snippets into a function might be challenging. Even if you successfully write the function, it could take a significant amount of time.

<details>

<summary>[6. Wrap all codes into a function]{style="color:blue"}</summary>

```{r}
create_summary_table <- function(data_ae, baseline_data, arm_var, ae_var, id_var) {
  # Get unique treatment arms
  treatment_arms <- unique(baseline_data[[arm_var]])
  
  # Get total subjects per arm
  total_subjects <- baseline_data %>%
    group_by(across(all_of(arm_var))) %>%
    summarise(total = n_distinct(across(all_of(id_var))), .groups = "drop")
  
  # Function to create summary for each arm
  summarize_arm <- function(arm_name) {
    summary_table <- data_ae %>%
      filter(.data[[arm_var]] == arm_name) %>%
      count(.data[[ae_var]], name = "n episode") %>%
      left_join(
        data_ae %>%
          filter(.data[[arm_var]] == arm_name) %>%
          distinct(across(all_of(ae_var)), across(all_of(id_var))) %>%
          count(.data[[ae_var]], name = "n patient"),
        by = ae_var
      ) %>%
      arrange(desc(`n episode`)) %>%
      mutate(across(all_of(ae_var), as.character))
    
    total_unique_patients <- data_ae %>%
      filter(.data[[arm_var]] == arm_name) %>%
      distinct(across(all_of(id_var))) %>%
      nrow()
    
    total_row <- tibble(
      !!ae_var := "Total",
      `n episode` = sum(summary_table$`n episode`, na.rm = TRUE),
      `n patient` = total_unique_patients
    )
    
    summary_table <- bind_rows(total_row, summary_table) %>%
      mutate(`n patient (%)` = sprintf("%d (%.1f%%)", `n patient`, `n patient` / total_subjects$total[total_subjects[[arm_var]] == arm_name] * 100)) %>%
      select(-`n patient`)  # Remove "n patient" column
    
    return(summary_table)
  }
  
  # Create summary tables for each arm
  summaries <- lapply(treatment_arms, summarize_arm)
  names(summaries) <- treatment_arms
  
  # Merge summaries dynamically
  final_summary <- Reduce(function(x, y) {
    full_join(x, y, by = ae_var, suffix = c("_1", "_2"))  # Use _1 and _2 instead of arm names
  }, summaries)
  
  # Replace NA values **after** full_join()
  final_summary <- final_summary %>%
    mutate(
      across(where(is.numeric) & contains("n episode"), ~ replace_na(., 0)), # Replace NA in "n episode" with 0
      across(where(is.character) & contains("n patient (%)"), ~ replace_na(., "0 (0%)")) # Replace NA in "n patient (%)" with "0 (0%)"
    )
  
  # Compute p-values
  compute_p_value <- function(arm1, arm2, total1, total2) {
    if (!is.na(arm1) && !is.na(arm2) && arm1 + arm2 > 0) {
      matrix_data <- matrix(c(arm1, total1 - arm1, arm2, total2 - arm2), nrow = 2, byrow = TRUE)
      format.pval(fisher.test(matrix_data)$p.value, digits = 3, eps = 0.001)
    } else {
      NA
    }
  }
  
  if (length(treatment_arms) == 2) {
    final_summary <- final_summary %>%
      rowwise() %>%
      mutate(`p value` = compute_p_value(
        as.numeric(str_extract(.data[["n patient (%)_1"]], "^\\d+")),
        as.numeric(str_extract(.data[["n patient (%)_2"]], "^\\d+")),
        total_subjects$total[total_subjects[[arm_var]] == treatment_arms[1]],
        total_subjects$total[total_subjects[[arm_var]] == treatment_arms[2]]
      )) %>%
      ungroup()
  }
  
  # Generate the base table
  final_summary_gt <- final_summary %>%
    gt() %>%
    tab_header(title = md("**Comparison of Adverse Events by Arm**")) %>%
    cols_label(
      !!ae_var := md("**Type of adverse event**"),
      `n episode_1` = "n episode",
      `n patient (%)_1` = "n patient (%)",
      `n episode_2` = "n episode",
      `n patient (%)_2` = "n patient (%)",
      `p value` = md("**p value**")
    ) %>%
    fmt_number(columns = starts_with("n episode"), decimals = 0) %>%
    tab_options(table.font.size = "medium") %>%
    tab_style(
      style = list(cell_text(weight = "bold")),
      locations = cells_body(rows = 1)  # Bold the total row
    )

  # Dynamically add tab_spanner() for each unique arm
  for (i in seq_along(treatment_arms)) {
    arm <- treatment_arms[i]
    arm_total <- total_subjects$total[total_subjects[[arm_var]] == arm]
    
    # Find column names that belong to this arm
    arm_cols <- colnames(final_summary)[grepl(paste0("_", i), colnames(final_summary))]
    
    # Add the spanner dynamically
    final_summary_gt <- final_summary_gt %>%
      tab_spanner(
        label = md(sprintf("**%s (N=%d)**", arm, arm_total)),
        columns = all_of(arm_cols)
      )
  }

  # Display the table
  return(final_summary_gt)
}


create_summary_table(data_ae = data_ae, baseline_data = baseline_data, arm_var = "Arm", ae_var = "ctcaename", id_var = "usubjid")
```

</details>

If you've already invested time in creating your function, why not share it with others by publishing it on GitHub? This way, others can save time by adapting your work. Alternatively, as a user, you might save time by finding an existing package that meets your needs.

In fact, OUCRU Biostat has an in-house package `C306` designed for this task—let’s take a look at it. Take a note that `sstable.ae` function from `C306` has many arguments for many additional features in the table. There are many other useful functions in `C306` such as: `sstable.baseline` to make the baseline table and `sstable.survcomp` to create survival comparison table.

<details>

<summary>[Alternative method: use OUCRU Biostat in-house package]{style="color:blue"}</summary>
```{r warning=F, message=F}
# library(devtools)
# devtools::install_github("oucru-biostats/C306@feature-rmst")
library(C306)

ae_table <- sstable.ae(
  ae_data = any_ae,
  fullid_data = baseline_data,
  id.var = "usubjid",
  aetype.var = c("ctcaename", "posrelunrel", "unexp"), # can combine three different tables into one
  grade.var = "original_ctcaegrade", 
  arm.var = "Arm",
  sort.by = ~ +p -ep -pt, # arrange in order of ascending for p_value and descending for episodes and patients.
  digits = 2,
  test = TRUE, # switch on and off the p-value
  test.anyae.only = FALSE, #show p value for all of the rows
  pdigits = 3,
  pcutoff = 0.001,
  chisq.test = F,
  footer = c("Example footnote for adverse event summary table."),
  flextable = T,
  bg = "#F2EFEE"
)

ae_table
```
</details>

::: {.callout-note .fragment}
Take-home message: Before writing your own function for a complex task, search for existing packages that match your needs. You might find one that does the job perfectly or requires only minimal adjustments, saving you a lot of time.
:::
